module garbage_trucks/backend

go 1.25.0

require (
	github.com/gorilla/mux v1.8.1
	github.com/jackc/pgx/v5 v5.8.0
	github.com/joho/godotenv v1.5.1
)

require (
	github.com/jackc/pgpassfile v1.0.0 // indirect
	github.com/jackc/pgservicefile v0.0.0-20240606120523-5a60cdf6a761 // indirect
	github.com/jackc/puddle/v2 v2.2.2 // indirect
	golang.org/x/sync v0.17.0 // indirect
	golang.org/x/text v0.29.0 // indirect
)


backend/
├── cmd/
│   └── server/
│       └── main.go               # точка входа, запускает сервер
├── internal/
│   ├── config/
│   │   └── config.go             # загрузка .env и структура конфигурации
│   ├── database/
│   │   └── db.go                 # подключение к PostgreSQL (pgxpool)
│   ├── models/
│   │   ├── driver.go             # модель и методы для водителей
│   │   ├── collection_point.go   # модель точек сбора
│   │   └── route.go              # модель маршрутов + методы
│   ├── handlers/
│   │   ├── health.go             # хендлер /api/health
│   │   ├── drivers.go            # хендлеры для /api/drivers
│   │   └── routes.go             # хендлеры для /api/routes и status
│   ├── middleware/
│   │   └── cors.go               # middleware для CORS
│   └── router/
│       └── router.go             # регистрация всех маршрутов (роутинг)
├── .env                          # переменные окружения (не коммитить!)
├── go.mod
└── go.sum

-- Создаём таблицу drivers
CREATE TABLE drivers (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- Создаём таблицу collection_points с FLOAT для координат
CREATE TABLE collection_points (
    id SERIAL PRIMARY KEY,
    name VARCHAR(200) NOT NULL,
    address VARCHAR(300),
    latitude FLOAT NOT NULL,
    longitude FLOAT NOT NULL,
    city VARCHAR(100) DEFAULT 'Рязань'
);

-- Создаём таблицу routes с улучшениями:
-- - scheduled_at вместо scheduled_time (TIMESTAMP для даты+времени)
-- - Добавлен visited_at (когда реально посетили)
-- - Добавлен comment (для заметок водителя)
-- - updated_at для отслеживания изменений
-- - Constraint на статус
CREATE TABLE routes (
    id SERIAL PRIMARY KEY,
    driver_id INTEGER NOT NULL REFERENCES drivers(id) ON DELETE CASCADE,
    point_id INTEGER NOT NULL REFERENCES collection_points(id) ON DELETE CASCADE,
    order_number INTEGER NOT NULL,
    scheduled_at TIMESTAMP WITH TIME ZONE NOT NULL,
    visited_at TIMESTAMP WITH TIME ZONE,
    completed_at TIMESTAMP WITH TIME ZONE,
    status VARCHAR(20) NOT NULL DEFAULT 'pending',
    comment TEXT,
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT valid_status CHECK (status IN ('pending', 'in_progress', 'completed', 'skipped', 'problem'))
);

-- Добавляем триггер для автоматического обновления updated_at
CREATE OR REPLACE FUNCTION update_updated_at()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_routes_updated_at
BEFORE UPDATE ON routes
FOR EACH ROW
EXECUTE FUNCTION update_updated_at();

-- Добавляем индексы для производительности
CREATE INDEX idx_routes_driver_id ON routes(driver_id);
CREATE INDEX idx_routes_status ON routes(status);
CREATE INDEX idx_routes_point_id ON routes(point_id);


# --- Настройки базы данных ---
DB_USER=postgres
DB_PASSWORD=toor
DB_HOST=localhost
DB_PORT=5432
DB_NAME=garbage_trucks

# --- Сервер ---
PORT=8080

# --- Другое ---
FRONTEND_URL=http://localhost:6000

package main

import (
	"log"
	"net/http"
	"garbage_trucks/backend/internal/config"
	"garbage_trucks/backend/internal/database"
	"garbage_trucks/backend/internal/router"
)

func main() {
	// Загружаем .env
	cfg := config.Load()

	// Подключаемся к базе данных
	database.Init(cfg)

	// Создаём роутер
	r := router.NewRouter()

	// Запускаем сервер
	log.Printf("Сервер запущен на http://localhost%s", cfg.Port)
	log.Fatal(http.ListenAndServe(cfg.Port, r))
}

package config

import (
	"os"

	"github.com/joho/godotenv"
)

type Config struct {
	DBUser     string
	DBPassword string
	DBHost     string
	DBPort     string
	DBName     string
	Port       string
	FrontendURL string
}

func Load() *Config {
	// Загружаем .env (если есть)
	godotenv.Load()

	return &Config{
		DBUser:     getEnv("DB_USER", "postgres"),
		DBPassword: getEnv("DB_PASSWORD", "postgres"),
		DBHost:     getEnv("DB_HOST", "localhost"),
		DBPort:     getEnv("DB_PORT", "5432"),
		DBName:     getEnv("DB_NAME", "garbage_trucks"),
		Port:       ":" + getEnv("PORT", "8080"),
		FrontendURL: getEnv("FRONTEND_URL", "http://localhost:3000"),
	}
}

func getEnv(key, fallback string) string {
	if value, exists := os.LookupEnv(key); exists {
		return value
	}
	return fallback
}

package database

import (
	"context"
	"fmt"
	"log"
	"garbage_trucks/backend/internal/config"

	"github.com/jackc/pgx/v5/pgxpool"
)

var Pool *pgxpool.Pool

func Init(cfg *config.Config) {
	connStr := fmt.Sprintf(
		"postgres://%s:%s@%s:%s/%s?sslmode=disable",
		cfg.DBUser, cfg.DBPassword, cfg.DBHost, cfg.DBPort, cfg.DBName,
	)

	var err error
	Pool, err = pgxpool.New(context.Background(), connStr)
	if err != nil {
		log.Fatal("Ошибка подключения к базе данных:", err)
	}

	if err = Pool.Ping(context.Background()); err != nil {
		log.Fatal("Пинг базы не прошёл:", err)
	}

	log.Println("Подключение к PostgreSQL установлено успешно!")
}

package handlers

import (
	"context"
	"encoding/json"
	"net/http"
	"garbage_trucks/backend/internal/models"
)

func GetDriversHandler(w http.ResponseWriter, r *http.Request) {
	drivers, err := models.GetAllDrivers(context.Background())
	if err != nil {
		http.Error(w, "Ошибка получения водителей", http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	if err := json.NewEncoder(w).Encode(drivers); err != nil {
		http.Error(w, "Ошибка кодирования ответа", http.StatusInternalServerError)
	}
}

package handlers

import (
	"encoding/json"
	"net/http"
)

func HealthHandler(w http.ResponseWriter, r *http.Request) {
	response := map[string]string{
		"status":  "ok",
		"message": "Garbage Trucks API работает!",
	}
	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(response)
}

package handlers

import (
	"context"
	"encoding/json"
	"net/http"
	"strconv"
	"garbage_trucks/backend/internal/models"
)

func GetRoutesHandler(w http.ResponseWriter, r *http.Request) {
	driverIDStr := r.URL.Query().Get("driver_id")
	if driverIDStr == "" {
		http.Error(w, "driver_id обязателен", http.StatusBadRequest)
		return
	}

	driverID, err := strconv.Atoi(driverIDStr)
	if err != nil {
		http.Error(w, "driver_id должен быть числом", http.StatusBadRequest)
		return
	}

	routes, err := models.GetRoutesByDriverID(context.Background(), driverID)
	if err != nil {
		http.Error(w, "Ошибка получения маршрута", http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	if err := json.NewEncoder(w).Encode(routes); err != nil {
		http.Error(w, "Ошибка кодирования ответа", http.StatusInternalServerError)
	}
}

func UpdateRouteStatusHandler(w http.ResponseWriter, r *http.Request) {
	if r.Method != "POST" {
		http.Error(w, "Метод не разрешён", http.StatusMethodNotAllowed)
		return
	}

	routeIDStr := r.URL.Query().Get("route_id")
	status := r.URL.Query().Get("status")

	if routeIDStr == "" || status == "" {
		http.Error(w, "route_id и status обязательны", http.StatusBadRequest)
		return
	}

	routeID, err := strconv.Atoi(routeIDStr)
	if err != nil {
		http.Error(w, "route_id должен быть числом", http.StatusBadRequest)
		return
	}

	err = models.UpdateRouteStatus(context.Background(), routeID, status)
	if err != nil {
		http.Error(w, "Ошибка обновления статуса", http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	if err := json.NewEncoder(w).Encode(map[string]string{"status": "success"}); err != nil {
		http.Error(w, "Ошибка кодирования ответа", http.StatusInternalServerError)
	}
}

package middleware

import "net/http"

func CORS(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Access-Control-Allow-Origin", "*")
		w.Header().Set("Access-Control-Allow-Methods", "GET, POST, OPTIONS")
		w.Header().Set("Access-Control-Allow-Headers", "Content-Type")

		if r.Method == http.MethodOptions {
			w.WriteHeader(http.StatusOK)
			return
		}

		next.ServeHTTP(w, r)
	})
}

package models

type CollectionPoint struct {
	ID        int     `json:"id"`
	Name      string  `json:"name"`
	Address   string  `json:"address"`
	Latitude  float64 `json:"latitude"`
	Longitude float64 `json:"longitude"`
	City      string  `json:"city"`
}

package models

import (
	"context"
	"garbage_trucks/backend/internal/database"
	"time"
)

type Driver struct {
	ID        int       `json:"id"`
	Name      string    `json:"name"`
	CreatedAt time.Time `json:"created_at,omitempty"`
}

func GetAllDrivers(ctx context.Context) ([]Driver, error) {
	rows, err := database.Pool.Query(ctx, `
		SELECT id, name, created_at 
		FROM drivers 
		ORDER BY id
	`)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var drivers []Driver
	for rows.Next() {
		var d Driver
		if err := rows.Scan(&d.ID, &d.Name, &d.CreatedAt); err != nil {
			return nil, err
		}
		drivers = append(drivers, d)
	}

	return drivers, rows.Err()
}


package models

import (
    "context"
    "time"
    "garbage_trucks/backend/internal/database"
)

type Route struct {
    ID           int              `json:"id"`
    DriverID     int              `json:"driver_id"`
    PointID      int              `json:"point_id"`
    OrderNumber  int              `json:"order_number"`
    ScheduledAt  time.Time        `json:"scheduled_at"`
    Status       string           `json:"status"`
    CompletedAt  *time.Time       `json:"completed_at,omitempty"`
    Comment      *string          `json:"comment,omitempty"`
    Point        *CollectionPoint `json:"point"`
}

func GetRoutesByDriverID(ctx context.Context, driverID int) ([]Route, error) {
    rows, err := database.Pool.Query(ctx, `
        SELECT 
            r.id, r.driver_id, r.point_id, r.order_number,
            r.scheduled_at, r.status, r.completed_at, r.comment,
            cp.name, cp.address, cp.latitude, cp.longitude, cp.city
        FROM routes r
        JOIN collection_points cp ON r.point_id = cp.id
        WHERE r.driver_id = $1
        ORDER BY r.order_number
    `, driverID)
    if err != nil {
        return nil, err
    }
    defer rows.Close()

    var routes []Route
    for rows.Next() {
        var r Route
        var completedAt *time.Time
        var comment *string
        var cpName, cpAddress, cpCity string
        var cpLat, cpLon float64

        err := rows.Scan(
            &r.ID, &r.DriverID, &r.PointID, &r.OrderNumber,
            &r.ScheduledAt, &r.Status, &completedAt, &comment,
            &cpName, &cpAddress, &cpLat, &cpLon, &cpCity,
        )
        if err != nil {
            return nil, err
        }

        r.CompletedAt = completedAt
        r.Comment = comment
        r.Point = &CollectionPoint{
            ID:        r.PointID,
            Name:      cpName,
            Address:   cpAddress,
            Latitude:  cpLat,
            Longitude: cpLon,
            City:      cpCity,
        }

        routes = append(routes, r)
    }

    return routes, rows.Err()
}

func UpdateRouteStatus(ctx context.Context, routeID int, status string) error {
    _, err := database.Pool.Exec(ctx, `
        UPDATE routes 
        SET status = $1, completed_at = CASE WHEN $1 = 'completed' THEN NOW() ELSE completed_at END
        WHERE id = $2
    `, status, routeID)
    return err
}

package router

import (
	"github.com/gorilla/mux"
	"garbage_trucks/backend/internal/handlers"
	"garbage_trucks/backend/internal/middleware"
)

func NewRouter() *mux.Router {
	r := mux.NewRouter()

	// Middleware
	r.Use(middleware.CORS)

	// API Routes
	r.HandleFunc("/api/health", handlers.HealthHandler).Methods("GET")
	r.HandleFunc("/api/drivers", handlers.GetDriversHandler).Methods("GET")
	r.HandleFunc("/api/routes", handlers.GetRoutesHandler).Methods("GET")
	r.HandleFunc("/api/routes/status", handlers.UpdateRouteStatusHandler).Methods("POST", "OPTIONS")

	return r
}










